# 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。
# 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
#

# 这题一上来很自然想到回溯，但是注意num的范围是全部整型数，必然会超时。因此使用动态规划
# 动态规划思路类似爬楼梯，每次要么使用一个数字（一级台阶），要么使用两个数字（两级台阶）
# 如果使用一个数字，那么相当于走到了前一位，然后本位使用一个数字，个数为dp[i-1]
# 如果使用两个数字，那么相当于走到了前两位，然后使用本位和前位数字，个数为dp[i-2]
# 在使用两个数字时，有两个判断。其一是两位数是否>25，也就是超过字母的表达上限。或者前位是否为0，就是01 02这样的是无法翻译的，
# 只有这两者都排除掉，才能使用两个数字，否则只能使用一个。

class Solution:
    def translateNum(self, num: int) -> int:
        if num == 0:
            return 1
        nums = []
        while num:
            nums.insert(0, num % 10)
            num = num // 10
        dp = [0] * (len(nums) + 1)
        dp[0] = dp[1] = 1
        for i in range(2, len(nums) + 1):
            if nums[i - 2] * 10 + nums[i - 1] > 25 or nums[i - 2] == 0:
                dp[i] = dp[i - 1]
            else:
                dp[i] = dp[i - 1] + dp[i - 2]
        return dp[-1]